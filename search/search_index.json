{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 Welcome to the Tu Graz Repository! Tu Graz Repository is a ready-to-go, turn-key Research Data Management repository. And an instance of InvenioRDM . Development \u00b6 Please visit the invenioRDM documentation for development section. > Getting Started Deployment \u00b6 Get to know current deployment workflow for Tu Graz repository . > Deployment Guides Configs \u00b6 For more configurations such as How the gitlab-runners are registered? How the Database is setup? And so much more... > Configurations","title":"Home"},{"location":"#home","text":"Welcome to the Tu Graz Repository! Tu Graz Repository is a ready-to-go, turn-key Research Data Management repository. And an instance of InvenioRDM .","title":"Home"},{"location":"#development","text":"Please visit the invenioRDM documentation for development section. > Getting Started","title":"Development"},{"location":"#deployment","text":"Get to know current deployment workflow for Tu Graz repository . > Deployment Guides","title":"Deployment"},{"location":"#configs","text":"For more configurations such as How the gitlab-runners are registered? How the Database is setup? And so much more... > Configurations","title":"Configs"},{"location":"configs/","text":"Configurations \u00b6 Configurations and setup of other services. > Gitlab runner > PostgreSQL > SSH-key > CEPH","title":"Configurations"},{"location":"configs/#configurations","text":"Configurations and setup of other services. > Gitlab runner > PostgreSQL > SSH-key > CEPH","title":"Configurations"},{"location":"configs/ceph/","text":"CephFS \u00b6 The Ceph File System, or CephFS, is a POSIX-compliant file system built on top of Ceph\u2019s distributed object store, RADOS. CephFS for repository \u00b6 3 Folders were created for each environment: Production environment - Quota 10TB /invenio/invenioprod: client 'fsinvenioprod', Secret in Sesam Test environment - Quota 1TB /invenio/inveniotest: client 'fsinveniotest', Secret in Sesam Dev environment - Quota 1TB /invenio/inveniodev: client 'fsinveniodev', Secret in Sesam In this guideline we will take a look on how the CEPH FS is configired for the production environment. Which is also the same for Dev and Test environments. Steps \u00b6 install ceph-common \u00b6 apt install ceph-common Create a file \u00b6 Create a file, and add the secret from sesam.tugraz nano /etc/ceph/ceph.client.fsinvenioprod Create a mount path \u00b6 Create a directory which will be mounted to the CEPH FS. mkdir /storage Test mount \u00b6 This will temporarily mount the directory `/storage to the /invenio/invenioprod mount -t ceph <ip:port>:/invenio/invenioprod /storage -o name = fsinvenioprod,secretfile = /etc/ceph/ceph.client.fsinvenioprod Check mounted file systems: \u00b6 df -h Filesystem Size Used Avail Use% Mounted on <ip:port>:/invenio/invenioprod 10T 0 10T 0% /storage Unmount \u00b6 After this temporarily mounting works, we will unmount it so later we can configure it properly. umount /storage/ Add Mount configuration \u00b6 open the /etc/fstab file and edit it as below: # <file system> <mount point> <type> <options> <dump> <pass> <ip:port>:/invenio/invenioprod /storage ceph _netdev,name = fsinvenioprod,secretfile = /etc/ceph/ceph.client.fsinvenioprod 0 0 Mount \u00b6 mount /storage","title":"CEPH"},{"location":"configs/ceph/#cephfs","text":"The Ceph File System, or CephFS, is a POSIX-compliant file system built on top of Ceph\u2019s distributed object store, RADOS.","title":"CephFS"},{"location":"configs/ceph/#cephfs-for-repository","text":"3 Folders were created for each environment: Production environment - Quota 10TB /invenio/invenioprod: client 'fsinvenioprod', Secret in Sesam Test environment - Quota 1TB /invenio/inveniotest: client 'fsinveniotest', Secret in Sesam Dev environment - Quota 1TB /invenio/inveniodev: client 'fsinveniodev', Secret in Sesam In this guideline we will take a look on how the CEPH FS is configired for the production environment. Which is also the same for Dev and Test environments.","title":"CephFS for repository"},{"location":"configs/ceph/#steps","text":"","title":"Steps"},{"location":"configs/ceph/#install-ceph-common","text":"apt install ceph-common","title":"install ceph-common"},{"location":"configs/ceph/#create-a-file","text":"Create a file, and add the secret from sesam.tugraz nano /etc/ceph/ceph.client.fsinvenioprod","title":"Create a file"},{"location":"configs/ceph/#create-a-mount-path","text":"Create a directory which will be mounted to the CEPH FS. mkdir /storage","title":"Create a mount path"},{"location":"configs/ceph/#test-mount","text":"This will temporarily mount the directory `/storage to the /invenio/invenioprod mount -t ceph <ip:port>:/invenio/invenioprod /storage -o name = fsinvenioprod,secretfile = /etc/ceph/ceph.client.fsinvenioprod","title":"Test mount"},{"location":"configs/ceph/#check-mounted-file-systems","text":"df -h Filesystem Size Used Avail Use% Mounted on <ip:port>:/invenio/invenioprod 10T 0 10T 0% /storage","title":"Check mounted file systems:"},{"location":"configs/ceph/#unmount","text":"After this temporarily mounting works, we will unmount it so later we can configure it properly. umount /storage/","title":"Unmount"},{"location":"configs/ceph/#add-mount-configuration","text":"open the /etc/fstab file and edit it as below: # <file system> <mount point> <type> <options> <dump> <pass> <ip:port>:/invenio/invenioprod /storage ceph _netdev,name = fsinvenioprod,secretfile = /etc/ceph/ceph.client.fsinvenioprod 0 0","title":"Add Mount configuration"},{"location":"configs/ceph/#mount","text":"mount /storage","title":"Mount"},{"location":"configs/gitlab-runner/","text":"Gitlab Runner \u00b6 GitLab Runner is an application that works with GitLab CI/CD to run jobs in a pipeline. Tu Graz Repository has a Gitlab group invenio . That has a group runner Gitlab-Runner-03-Produktion-Invenio-Shell , which is provided by ZID . We are using this group runner to run our Pipeline jobs, from gitlab to our VM server's. How the GitLab runners are registered? \u00b6 Access the node - for example: ssh mojib@instance_prod.tugraz.at then enter your password from sesam.tugraz to gain access to the server. Add GitLab\u2019s official repository . curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash install the gitlab-runner apt install gitlab-runner Register the gitlab-runner for your group runner. gitlab-runner register Input Value gitlab-ci URL: https://gitlab.tugraz.at/ gitlab-ci token: Check sesam.tugraz gitlab-ci description: invenio01-prod gitlab-ci tags: prod-one executor: shell Make sure to give permission. usermod -aG docker gitlab-runner . Runner is registered successfully. Now you should be able to see your Gitlab-runner in the list here . Possible Errors \u00b6 These error might apear when using this registered runner for the first time. The runner throws an ERROR ERROR: Job failed (system failure): prepare environment: exit status 1 SEE HERE . Solution Remove/comment .bash_logout entries. Access your VM server Navigate to /home/gitlab-runner Look for file called .bash_logout Remove or comment the entries on this file Error saving credentials Error saving credentials: error storing credentials - err: exit status 1, out: `Cannot autolaunch D-Bus without X11 $DISPLAY Solution: install package in VM apt install gnupg2 pass . To learn more Gitlab-runner commands, visit the GitLab Runner commands .","title":"Gitlab Runner"},{"location":"configs/gitlab-runner/#gitlab-runner","text":"GitLab Runner is an application that works with GitLab CI/CD to run jobs in a pipeline. Tu Graz Repository has a Gitlab group invenio . That has a group runner Gitlab-Runner-03-Produktion-Invenio-Shell , which is provided by ZID . We are using this group runner to run our Pipeline jobs, from gitlab to our VM server's.","title":"Gitlab Runner"},{"location":"configs/gitlab-runner/#how-the-gitlab-runners-are-registered","text":"Access the node - for example: ssh mojib@instance_prod.tugraz.at then enter your password from sesam.tugraz to gain access to the server. Add GitLab\u2019s official repository . curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash install the gitlab-runner apt install gitlab-runner Register the gitlab-runner for your group runner. gitlab-runner register Input Value gitlab-ci URL: https://gitlab.tugraz.at/ gitlab-ci token: Check sesam.tugraz gitlab-ci description: invenio01-prod gitlab-ci tags: prod-one executor: shell Make sure to give permission. usermod -aG docker gitlab-runner . Runner is registered successfully. Now you should be able to see your Gitlab-runner in the list here .","title":"How the GitLab runners are registered?"},{"location":"configs/gitlab-runner/#possible-errors","text":"These error might apear when using this registered runner for the first time. The runner throws an ERROR ERROR: Job failed (system failure): prepare environment: exit status 1 SEE HERE . Solution Remove/comment .bash_logout entries. Access your VM server Navigate to /home/gitlab-runner Look for file called .bash_logout Remove or comment the entries on this file Error saving credentials Error saving credentials: error storing credentials - err: exit status 1, out: `Cannot autolaunch D-Bus without X11 $DISPLAY Solution: install package in VM apt install gnupg2 pass . To learn more Gitlab-runner commands, visit the GitLab Runner commands .","title":"Possible Errors"},{"location":"configs/postgresql/","text":"PostgreSQL \u00b6 PostgreSQL also known as Postgres, is a free and open-source relational database management system (RDBMS) emphasizing extensibility and SQL compliance. In this guideline we will take a look on the Postgresql database setup and configurations for Repository Production instance. Using PostgreSQL Version 11 , and VM invenio03-prod.tugraz.at Installation \u00b6 $ apt-get update $ apt-get install postgresql postgresql-contrib By default PostgreSQL has a default user postgres . We can access the database with this user su postgres and access the shell with psql . To change the postgres user password: $ su postgres ( postgres ) $ psql ( postgres ) ALTER USER postgres WITH PASSWORD '************' ; Users and Database \u00b6 Create a admin user: CREATE USER admin WITH PASSWORD '************' ; Give the user permissions: ALTER USER admin WITH SUPERUSER ; Create Database: CREATE database repository ; Grant permissions of database for admin user: GRANT ALL PRIVILEGES ON DATABASE \"repository\" to admin ; Configuration \u00b6 Allow access \u00b6 Allow access to the webserver VMs. Open the /etc/postgresql/11/main/pg_hba.conf file and edit it as below: # TYPE DATABASE USER ADDRESS METHOD host all <user> ********/28 trust host all <user> ********/28 trust host all <user> repository.tugraz.at trust Listen address \u00b6 Listen to other VMs. Open the /etc/postgresql/11/main/postgresql.conf file and edit it as below: #------------------------------------------------------------------------------ # CONNECTIONS AND AUTHENTICATION #------------------------------------------------------------------------------ # - Connection Settings - - #listen_addresses = 'localhost' # what IP address(es) to listen on; + listen_addresses = '<ip addresses>' # what IP address(es) to listen on; Test connection \u00b6 Access the database from one of the configured machines. psql Make sure you have postgres client installed. psql -U admin -d repository -h <host ip address>","title":"PostgreSQL"},{"location":"configs/postgresql/#postgresql","text":"PostgreSQL also known as Postgres, is a free and open-source relational database management system (RDBMS) emphasizing extensibility and SQL compliance. In this guideline we will take a look on the Postgresql database setup and configurations for Repository Production instance. Using PostgreSQL Version 11 , and VM invenio03-prod.tugraz.at","title":"PostgreSQL"},{"location":"configs/postgresql/#installation","text":"$ apt-get update $ apt-get install postgresql postgresql-contrib By default PostgreSQL has a default user postgres . We can access the database with this user su postgres and access the shell with psql . To change the postgres user password: $ su postgres ( postgres ) $ psql ( postgres ) ALTER USER postgres WITH PASSWORD '************' ;","title":"Installation"},{"location":"configs/postgresql/#users-and-database","text":"Create a admin user: CREATE USER admin WITH PASSWORD '************' ; Give the user permissions: ALTER USER admin WITH SUPERUSER ; Create Database: CREATE database repository ; Grant permissions of database for admin user: GRANT ALL PRIVILEGES ON DATABASE \"repository\" to admin ;","title":"Users and Database"},{"location":"configs/postgresql/#configuration","text":"","title":"Configuration"},{"location":"configs/postgresql/#allow-access","text":"Allow access to the webserver VMs. Open the /etc/postgresql/11/main/pg_hba.conf file and edit it as below: # TYPE DATABASE USER ADDRESS METHOD host all <user> ********/28 trust host all <user> ********/28 trust host all <user> repository.tugraz.at trust","title":"Allow access"},{"location":"configs/postgresql/#listen-address","text":"Listen to other VMs. Open the /etc/postgresql/11/main/postgresql.conf file and edit it as below: #------------------------------------------------------------------------------ # CONNECTIONS AND AUTHENTICATION #------------------------------------------------------------------------------ # - Connection Settings - - #listen_addresses = 'localhost' # what IP address(es) to listen on; + listen_addresses = '<ip addresses>' # what IP address(es) to listen on;","title":"Listen address"},{"location":"configs/postgresql/#test-connection","text":"Access the database from one of the configured machines. psql Make sure you have postgres client installed. psql -U admin -d repository -h <host ip address>","title":"Test connection"},{"location":"configs/sshkey/","text":"SSH-key \u00b6 Services VM deployment is using direct ssh commands to reach the VM. In order to know the ssh keys configuration, please take a look into the steps below: Generate ssh-key in VM \u00b6 This command will generate a new ssh-key. $ ssh-keygen Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. Add private key to CI/CD variable \u00b6 we have defined a variable PROD_03_PRIVATE_KEY in our Gitlab invenio group variable . And we are adding the generated private key /root/.ssh/id_rsa to PROD_03_PRIVATE_KEY . authorized_keys \u00b6 The authorized_keys file in SSH specifies the SSH keys that can be used for logging into the user account for which the file is configured. Add public key to authorized_keys: $ cat /root/.ssh/id_rsa.pub >> /.ssh/authorized_keys known_hosts \u00b6 group runner Gitlab-Runner-03-Produktion-Invenio-Shell has a known_hosts that contains a list of public keys for all the hosts which the user has connected to. These list of public keys are in CI/CD variable SSH_SERVER_HOSTKEYS . To add new host: $ ssh-keyscan invenio03-prod.tugraz.at And then update the variable SSH_SERVER_HOSTKEYS .","title":"SSH-key"},{"location":"configs/sshkey/#ssh-key","text":"Services VM deployment is using direct ssh commands to reach the VM. In order to know the ssh keys configuration, please take a look into the steps below:","title":"SSH-key"},{"location":"configs/sshkey/#generate-ssh-key-in-vm","text":"This command will generate a new ssh-key. $ ssh-keygen Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub.","title":"Generate ssh-key in VM"},{"location":"configs/sshkey/#add-private-key-to-cicd-variable","text":"we have defined a variable PROD_03_PRIVATE_KEY in our Gitlab invenio group variable . And we are adding the generated private key /root/.ssh/id_rsa to PROD_03_PRIVATE_KEY .","title":"Add private key to CI/CD variable"},{"location":"configs/sshkey/#authorized_keys","text":"The authorized_keys file in SSH specifies the SSH keys that can be used for logging into the user account for which the file is configured. Add public key to authorized_keys: $ cat /root/.ssh/id_rsa.pub >> /.ssh/authorized_keys","title":"authorized_keys"},{"location":"configs/sshkey/#known_hosts","text":"group runner Gitlab-Runner-03-Produktion-Invenio-Shell has a known_hosts that contains a list of public keys for all the hosts which the user has connected to. These list of public keys are in CI/CD variable SSH_SERVER_HOSTKEYS . To add new host: $ ssh-keyscan invenio03-prod.tugraz.at And then update the variable SSH_SERVER_HOSTKEYS .","title":"known_hosts"},{"location":"deployment/","text":"Infrastructure \u00b6 Tu Graz Repository has 3 instances running on Debian (VMs). Development Instance \u00b6 invenio-dev01.tugraz.at Development instance has 1 VM: Web Server/Services VM (invenio-dev01) Test Instance \u00b6 invenio-test.tugraz.at Test instance has 3 VMs: Web Server VM (invenio01-test) Web Server VM (invenio02-test) Services VM (invenio03-test) Production Instance \u00b6 repository.tugraz.at Production instance has 3 VMs: Web Server VM (invenio01-prod) Web Server VM (invenio02-prod) Services VM (invenio03-prod) The virtual machines for Test and Production are split into two categories, Web Server and Services . In this guideline we will take a look on both: Web Server VM \u00b6 Base image of the repository instance. UWSGI Celery Web Server VMs are configured to the F5 load balancer that is provided by Tu Graz ZID . The load balancer is forwarding the requests to one of the (Web Server VM), and then the requests are proxied by NGINX to UWSGI web applications . As shown below: Services VM \u00b6 Services VM - consist of some services for the Repository such as: Elasticsearch is a search engine based on the Lucene library. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents. Elasticsearch is developed in Java. PostgreSQL is a free and open-source relational database management system (RDBMS) emphasizing extensibility and SQL compliance. Redis Remote Dictionary Server is an in-memory data structure project implementing a distributed, in-memory key\u2013value database with optional durability. Redis supports different kinds of abstract data structures, such as strings, lists, maps, sets, sorted sets, HyperLogLogs, bitmaps, streams, and spatial indexes. EXIM4 Exim4 is a Message Transfer Agent (MTA) developed at the University of Cambridge for use on Unix systems connected to the Internet. Exim can be installed in place of sendmail, although its configuration is quite different. RabbitMQ RabbitMQ is an open-source message-broker software that originally implemented the Advanced Message Queuing Protocol and has since been extended with a plug-in architecture to support Streaming Text Oriented Messaging Protocol, MQ Telemetry Transport.","title":"Infrastructure"},{"location":"deployment/#infrastructure","text":"Tu Graz Repository has 3 instances running on Debian (VMs).","title":"Infrastructure"},{"location":"deployment/#development-instance","text":"invenio-dev01.tugraz.at Development instance has 1 VM: Web Server/Services VM (invenio-dev01)","title":"Development Instance"},{"location":"deployment/#test-instance","text":"invenio-test.tugraz.at Test instance has 3 VMs: Web Server VM (invenio01-test) Web Server VM (invenio02-test) Services VM (invenio03-test)","title":"Test Instance"},{"location":"deployment/#production-instance","text":"repository.tugraz.at Production instance has 3 VMs: Web Server VM (invenio01-prod) Web Server VM (invenio02-prod) Services VM (invenio03-prod) The virtual machines for Test and Production are split into two categories, Web Server and Services . In this guideline we will take a look on both:","title":"Production Instance"},{"location":"deployment/#web-server-vm","text":"Base image of the repository instance. UWSGI Celery Web Server VMs are configured to the F5 load balancer that is provided by Tu Graz ZID . The load balancer is forwarding the requests to one of the (Web Server VM), and then the requests are proxied by NGINX to UWSGI web applications . As shown below:","title":"Web Server VM"},{"location":"deployment/#services-vm","text":"Services VM - consist of some services for the Repository such as: Elasticsearch is a search engine based on the Lucene library. It provides a distributed, multitenant-capable full-text search engine with an HTTP web interface and schema-free JSON documents. Elasticsearch is developed in Java. PostgreSQL is a free and open-source relational database management system (RDBMS) emphasizing extensibility and SQL compliance. Redis Remote Dictionary Server is an in-memory data structure project implementing a distributed, in-memory key\u2013value database with optional durability. Redis supports different kinds of abstract data structures, such as strings, lists, maps, sets, sorted sets, HyperLogLogs, bitmaps, streams, and spatial indexes. EXIM4 Exim4 is a Message Transfer Agent (MTA) developed at the University of Cambridge for use on Unix systems connected to the Internet. Exim can be installed in place of sendmail, although its configuration is quite different. RabbitMQ RabbitMQ is an open-source message-broker software that originally implemented the Advanced Message Queuing Protocol and has since been extended with a plug-in architecture to support Streaming Text Oriented Messaging Protocol, MQ Telemetry Transport.","title":"Services VM"},{"location":"deployment/deploy/","text":"Deploy \u00b6 Ready to deploy your changes in one of our instances: In this guideline, we will take a look at when the pipeline for different instances is executed. Deploy Dev ( Development instance ) Deploy Test ( Test instance ) Deploy Production ( Production instance ) Deploy Dev \u00b6 Every time there is a branch dev or merge_request to the branch master of Repository the pipeline stage for dev is executed. Pipeline \u00b6 Deploy Test \u00b6 Every commit or merge to the master branch of Repository will run Pipeline and deploy the changes to the Test instance . Pipeline \u00b6 Deploy Production \u00b6 Every new Tag/release of the Repository will run Pipeline and deploy the changes to the Production instance . Steps \u00b6 Deployment to production requires a new Tag/release of the Repository . Meaning we should only deploy to production when we have a new Tag/release . 1. Before creating a new Tag/release first we must change the value of TAG_PROD in GitLab CI/CD variables , to our expected new Tag/release version. For example the following change in TAG_PROD variable: - TAG_PROD=v0.1.1 + TAG_PROD=v0.1.2 2. Create a new Tag/release for the Repository , using semantic-versioning. for example v0.1.2 , same value as in the .env file. For Example using git: git tag -a v0.1.2 -m \"my version 0.1.2\" Pipeline \u00b6","title":"Deploy"},{"location":"deployment/deploy/#deploy","text":"Ready to deploy your changes in one of our instances: In this guideline, we will take a look at when the pipeline for different instances is executed. Deploy Dev ( Development instance ) Deploy Test ( Test instance ) Deploy Production ( Production instance )","title":"Deploy"},{"location":"deployment/deploy/#deploy-dev","text":"Every time there is a branch dev or merge_request to the branch master of Repository the pipeline stage for dev is executed.","title":"Deploy Dev"},{"location":"deployment/deploy/#pipeline","text":"","title":"Pipeline"},{"location":"deployment/deploy/#deploy-test","text":"Every commit or merge to the master branch of Repository will run Pipeline and deploy the changes to the Test instance .","title":"Deploy Test"},{"location":"deployment/deploy/#pipeline_1","text":"","title":"Pipeline"},{"location":"deployment/deploy/#deploy-production","text":"Every new Tag/release of the Repository will run Pipeline and deploy the changes to the Production instance .","title":"Deploy Production"},{"location":"deployment/deploy/#steps","text":"Deployment to production requires a new Tag/release of the Repository . Meaning we should only deploy to production when we have a new Tag/release . 1. Before creating a new Tag/release first we must change the value of TAG_PROD in GitLab CI/CD variables , to our expected new Tag/release version. For example the following change in TAG_PROD variable: - TAG_PROD=v0.1.1 + TAG_PROD=v0.1.2 2. Create a new Tag/release for the Repository , using semantic-versioning. for example v0.1.2 , same value as in the .env file. For Example using git: git tag -a v0.1.2 -m \"my version 0.1.2\"","title":"Steps"},{"location":"deployment/deploy/#pipeline_2","text":"","title":"Pipeline"},{"location":"deployment/workflow/","text":"Deployment Workflow \u00b6 The deployment workflow for Test Instance & Production Instance are the same. To understand how the deployment works. We will divide the process into two sections. Web Server deployment Services deployment Web Server deployment \u00b6 The Repository is the Web server, which holds all the files and data to build the application's base image and run the docker containers to our instances. The base image is a Docker image that will include all the dependencies required to run the application web-server, and its build with the help of Dockerfile and the commands define in it. From the base image then we are running three containers web-ui , web-api , and a worker with the help of the docker-compose file, as shown below. Alongside running our three containers from the base image, the docker-compose is also responsible to push NGINX container to our servers. which then proxies the requests to the web-ui , and web-api , as shown below: docker-compose \u00b6 docker-compose is a tool for defining and running multi-container Docker applications In Repository there are two docker-compose files. doker-compose-test.yml As the name suggests this docker-compose file is used for Test Instance . docker-compose-prod.yml As the name suggests this docker-compose file is used for Production Instance . # -*- coding: utf-8 -*- # # Copyright (C) 2021 Graz University of Technology # Maintainer Mojib Wali # # Following services are included: # - Frontend server: Nginx (exposed port: 8080) # - UI application: UWSGI (not exposed) # - API application: UWSGI (not exposed) # - Worker: Celery (not exposed) version : '2.2' services : # Frontend frontend : image : registry.gitlab.tugraz.at/invenio/nginx:prod restart : \"always\" volumes : - static_data:/opt/invenio/var/instance/static links : - web-ui - web-api ports : - \"8080:8080\" # UI Application web-ui : command : [ \"uwsgi /opt/invenio/var/instance/uwsgi_ui.ini\" ] image : registry.gitlab.tugraz.at/invenio/repository:${TAG_PROD} env_file : ${ENV_FILE_PROD} ports : - \"5000\" volumes : - static_data:/opt/invenio/var/instance/static - uploaded_data:/opt/invenio/var/instance/data - archived_data:/opt/invenio/var/instance/archive # API Rest Application web-api : command : [ \"uwsgi /opt/invenio/var/instance/uwsgi_rest.ini\" ] image : registry.gitlab.tugraz.at/invenio/repository:${TAG_PROD} env_file : ${ENV_FILE_PROD} ports : - \"5000\" volumes : - uploaded_data:/opt/invenio/var/instance/data - archived_data:/opt/invenio/var/instance/archive # Worker worker : restart : \"always\" env_file : ${ENV_FILE_PROD} command : [ \"celery -A invenio_app.celery worker --loglevel=INFO\" ] image : registry.gitlab.tugraz.at/invenio/repository:${TAG_PROD} volumes : static_data : uploaded_data : driver : local driver_opts : type : none o : bind device : /storage archived_data : Both docker-compose files have the same commands, but diffrent conatiner names and environment variables. Dockerfile \u00b6 A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. The Dockerfile for Repository , as below. # Dockerfile that builds a fully functional image of your app. # # This image installs all Python dependencies for your application. It's based # on CentOS 8 with Python 3.8 (https://github.com/inveniosoftware/docker-invenio) # and includes Pip, Pipenv, Node.js, NPM and some few standard libraries # Repository usually needs. # Pulling Centos8 with python3.8 image. FROM inveniosoftware/centos8-python:3.8 # env arg ARG ENVIRONMENT # These packages are required for shibboleth authentication. # Installing xmlsec packages RUN yum localinstall -y http://mirror.centos.org/centos/8/PowerTools/x86_64/os/Packages/xmlsec1-devel-1.2.25-4.el8.x86_64.rpm \\ http://mirror.centos.org/centos/8/PowerTools/x86_64/os/Packages/xmlsec1-openssl-devel-1.2.25-4.el8.x86_64.rpm # Installing libtool package RUN yum localinstall -y http://mirror.centos.org/centos/8/AppStream/x86_64/os/Packages/libtool-ltdl-devel-2.4.6-25.el8.x86_64.rpm # Copy Pipfile and pipfile.lock to ./ directory COPY Pipfile Pipfile.lock ./ # Install all the dependecies defined in the Pipfile. RUN pipenv install --deploy --system --pre # Copy other necessary files COPY ./docker/uwsgi/ ${ INVENIO_INSTANCE_PATH } COPY ./prod/invenio.cfg ${ INVENIO_INSTANCE_PATH } COPY ./templates/ ${ INVENIO_INSTANCE_PATH } /templates/ COPY ./app_data/ ${ INVENIO_INSTANCE_PATH } /app_data/ COPY ./ . # This will create, install and build all the statics & assets. RUN cp -r ./static/. ${ INVENIO_INSTANCE_PATH } /static/ && \\ cp -r ./assets/. ${ INVENIO_INSTANCE_PATH } /assets/ && \\ invenio collect --verbose && \\ invenio webpack create && \\ invenio webpack install --unsafe && \\ invenio webpack build # Instruction used to configure how the container will run. ENTRYPOINT [ \"bash\" , \"-c\" ] Pipeline \u00b6 .gitlab-ci.yml \u00b6 is a YAML file that you create on your project's root. This file automatically runs whenever you push code in the repository. Pipelines consist of one or more stages that run in order and can each contain one or more jobs that run in parallel. These jobs (or scripts) get executed by the GitLab Runner agent. Repository pipeline consist of seven stages : dev \u00b6 In this stage the pipeline is building base image for Dev instance , and deploying it to the development server https://invenio-dev01.tugraz.at . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.dev.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Build and push base image to gitlab Container Registry .Using Tag name DEV . Run docker-compose for scripts in docker-compose.dev.yml file, and deploy to the development instance. Run wipe_recreate.sh scripts for clean Db, Es, Cache and demo rdm records. script: - echo \"build the image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$DEV --build-arg ENVIRONMENT=DEV . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$DEV - echo \"run docker-compose...\" - docker-compose -f docker-compose.dev.yml up -d - echo \"create demo records..\" - docker exec repository_web-api_1 chmod +x ./wipe_recreate.sh - docker exec repository_web-api_1 ./wipe_recreate.sh Only run for branch dev & merge_requests to the master branch. only: - dev - merge_requests Execute jobs with Gitlab-runner tag name dev : tags: - dev Full dev stage: dev-deploy: stage: dev before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.dev.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"build the image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$DEV --build-arg ENVIRONMENT=DEV . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$DEV - echo \"run docker-compose...\" - docker-compose -f docker-compose.dev.yml up -d - echo \"create demo records..\" - docker exec repository_web-api_1 chmod +x ./wipe_recreate.sh - docker exec repository_web-api_1 ./wipe_recreate.sh only: - dev - merge_requests tags: - dev build_test \u00b6 In this stage the pipeline is building base image for Test instance . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Build and push base image to gitlab Container Registry . Using Tag name TEST . script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$TEST --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$TEST Only run for branch master & test . only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell Full build_test stage: build-test: stage: build_test before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$TEST --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$TEST after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - shell test_one \u00b6 In this stage pipeline is deploying the base image to the Web Server(invenio01-test) . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Run docker-compose, pull images and run containers defined in docker-compose.test.yml file. script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d Only run for branch master & test . only: - master Execute jobs with Gitlab-runner tag name test01 : tags: - test01 Logout from docker after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" Full test_one stage: test_one-deploy: stage: test_one before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test01 test_two \u00b6 In this stage pipeline is deploying the base image to the Web Server(invenio02-test) . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Run docker-compose, pull images and run containers defined in docker-compose.test.yml file. script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d Only run for branch master & test . only: - master Execute jobs with Gitlab-runner tag name test02 : tags: - test02 Logout from docker after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" Full test_two stage: test_two-deploy: stage: test_two before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test02 Full .gitlab-ci.yml \u00b6 # environment variables # environment variables variables: DEV: dev TEST: test # Pipline stages stages: - dev - build_test - test_one - test_two - build_prod - prod_one - prod_two # Build & deploy stage for dev instance dev-deploy: stage: dev before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.dev.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"build the image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$DEV --build-arg ENVIRONMENT=DEV . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$DEV - echo \"run docker-compose...\" - docker-compose -f docker-compose.dev.yml up -d - echo \"create demo records..\" - docker exec repository_web-api_1 chmod +x ./wipe_recreate.sh - docker exec repository_web-api_1 ./wipe_recreate.sh only: - dev - merge_requests tags: - dev # Build stage for test instance build-test: stage: build_test before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$TEST --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$TEST after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - shell # Deploy stage for web server 01 test_one-deploy: stage: test_one before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test01 # Deploy stage for web server 02 test_two-deploy: stage: test_two before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test02 ################################################# # Build stage for prod build_prod: stage: build_prod before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$CI_COMMIT_TAG --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$CI_COMMIT_TAG after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - tags tags: - shell # Deploy stage for web server 01 prod_one-deploy: stage: prod_one before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.prod.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.prod.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - tags tags: - prod01 # Deploy stage for web server 02 prod_two-deploy: stage: prod_two before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.prod.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.prod.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - tags tags: - prod02 Services deployment \u00b6 Services such as Elasticsearch , PostgreSQL , Redis , EXIM4 , and RabbitMQ have a seperate repository in the Gitlab Group invenio . Except PostgreSQL other Services deployment are the same. EXIM4 \u00b6 Dockerfile \u00b6 A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. The Dockerfile for EXIM4 , as below. FROM debian:jessie # This dockerfile was inpired by greinacker/exim4 # install packages: exim4, mailutils RUN apt-get update \\ && apt-get install --no-install-recommends -y \\ exim4-daemon-light mailutils xtail vim \\ # Slim down image && apt-get clean \\ && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* /usr/share/man/?? /usr/share/man/??_* # add the exim4 start script ADD start.sh /exim_start RUN chmod +x /exim_start ENV EXIM_LOCALINTERFACE = 0 .0.0.0 ENTRYPOINT [ \"/exim_start\" ] deploy-prod.sh \u00b6 Is a helper file for deployment, and used by .gitlab-ci.yml . It contains instruction for docker commands. CONTAINER_NAME = smarthost IMAGE_NAME = registry.gitlab.tugraz.at/invenio/exim4:latest echo \"################################################\" echo \"Stopping and removing container with given name...... $CONTAINER_NAME \" docker stop $CONTAINER_NAME || true && docker rm $CONTAINER_NAME || true echo \"################################################\" echo \"Removing image if given name exists... $IMAGE_NAME \" if test ! -z \" $( docker images -q $IMAGE_NAME ) \" ; then echo \"Image exist...\" docker rmi -f $IMAGE_NAME fi echo \"################################################\" echo \"Running new container..............\" docker run --name = \" $CONTAINER_NAME \" -p 25 :25 -d \\ -e HOSTNAME = \"repository.tugraz.at\" \\ -e EXIM_SMARTHOST = \"**********\" \\ -e EXIM_PASSWORD = \"**********\" \\ -e EXIM_LOCALINTERFACE = \"0.0.0.0\" \\ -e EXIM_DOMAIN = \"repository.tugraz.at\" \\ -e EXIM_ALLOWED_SENDERS = \"**********/28, **********/28\" \\ --restart = always \\ $IMAGE_NAME echo \"################################################\" echo \"job ended...\" .gitlab-ci.yml \u00b6 EXIM4 pipeline consist of three stages build \u00b6 Pipeline builds the docker image and pushes it to the Registry. Login to docker: before_script: - echo \"################################\" - echo \"login to docker...\" - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY Build and push docker image: script: - echo \"################################\" - echo \"Building the image...\" - docker build -t \"$CI_REGISTRY_IMAGE\" . - echo \"push image to registry...\" - docker push \"$CI_REGISTRY_IMAGE\" Only run for branch master : only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell test \u00b6 In this stage the pipeline pulls the newly created image and creates a container to the Test instance. before_script run followings: Install ssh-agent if not already installed, it is required by Docker. Run ssh-agent (inside the build environment) Add the SSH key stored in SERVER_3_PRIVATE_KEY variable to the agent store Create the SSH directory and give it the right permissions scan the keys of your private server from variable SSH_SERVER_HOSTKEYS before_script: - echo \"SSH-USER\" - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' - eval $(ssh-agent -s) - echo \"$SERVER_3_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script : using ssh commands logs in to docker, and runs scripts in deploy-test.sh to our server. script: - ssh $SERVER_3_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $SERVER_3_DOMAIN \"eval '$(cat ./deploy-test.sh)'\" Only run for branch master : only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell prod \u00b6 In this stage the pipeline pulls the newly created image and creates a container to the Production instance. before_script run followings: Install ssh-agent if not already installed, it is required by Docker. Run ssh-agent (inside the build environment) Add the SSH key stored in PROD_03_PRIVATE_KEY variable to the agent store Create the SSH directory and give it the right permissions scan the keys of your private server from variable SSH_SERVER_HOSTKEYS before_script: - echo \"SSH-USER\" - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' - eval $(ssh-agent -s) - echo \"$PROD_03_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script : using ssh commands logs in to docker, and runs scripts in deploy-prod.sh to our server. script: - ssh $PROD_03_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $PROD_03_DOMAIN \"eval '$(cat ./deploy-prod.sh)'\" Only run for branch master : only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell Full .gitlab-ci.yml \u00b6 stages: - build - test - prod build: stage: build before_script: - echo \"################################\" - echo \"login to docker...\" - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY script: - echo \"################################\" - echo \"Building the image...\" - docker build -t \"$CI_REGISTRY_IMAGE\" . - echo \"push image to registry...\" - docker push \"$CI_REGISTRY_IMAGE\" only: - master tags: - shell test: stage: test before_script: - echo \"################################\" - echo \"SSH-USER\" ## ## Install ssh-agent if not already installed, it is required by Docker. ## (change apt-get to yum if you use an RPM-based image) ## - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' ## ## Run ssh-agent (inside the build environment) ## - eval $(ssh-agent -s) ## ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store ## We're using tr to fix line endings which makes ed25519 keys work ## without extra base64 encoding. ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556 ## - echo \"$SERVER_3_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - ## ## Create the SSH directory and give it the right permissions ## - mkdir -p ~/.ssh - chmod 700 ~/.ssh ## ## Use ssh-keyscan to scan the keys of your private server. Replace gitlab.com ## with your own domain name. You can copy and repeat that command if you have ## more than one server to connect to. ## #- ssh-keyscan invenio03-test.tugraz.at >> ~/.ssh/known_hosts #- chmod 644 ~/.ssh/known_hosts ## ## Alternatively, assuming you created the SSH_SERVER_HOSTKEYS variable ## previously, uncomment the following two lines instead. ## - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script: - echo \"################################\" - ssh $SERVER_3_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $SERVER_3_DOMAIN \"eval '$(cat ./deploy-test.sh)'\" only: - master tags: - shell prod: stage: prod before_script: - echo \"################################\" - echo \"SSH-USER\" ## ## Install ssh-agent if not already installed, it is required by Docker. ## (change apt-get to yum if you use an RPM-based image) ## - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' ## ## Run ssh-agent (inside the build environment) ## - eval $(ssh-agent -s) ## ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store ## We're using tr to fix line endings which makes ed25519 keys work ## without extra base64 encoding. ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556 ## - echo \"$PROD_03_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - ## ## Create the SSH directory and give it the right permissions ## - mkdir -p ~/.ssh - chmod 700 ~/.ssh ## ## Use ssh-keyscan to scan the keys of your private server. Replace gitlab.com ## with your own domain name. You can copy and repeat that command if you have ## more than one server to connect to. ## #- ssh-keyscan invenio03-test.tugraz.at >> ~/.ssh/known_hosts #- chmod 644 ~/.ssh/known_hosts ## ## Alternatively, assuming you created the SSH_SERVER_HOSTKEYS variable ## previously, uncomment the following two lines instead. ## - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script: - echo \"################################\" - ssh $PROD_03_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $PROD_03_DOMAIN \"eval '$(cat ./deploy-prod.sh)'\" only: - master tags: - shell","title":"Workflow"},{"location":"deployment/workflow/#deployment-workflow","text":"The deployment workflow for Test Instance & Production Instance are the same. To understand how the deployment works. We will divide the process into two sections. Web Server deployment Services deployment","title":"Deployment Workflow"},{"location":"deployment/workflow/#web-server-deployment","text":"The Repository is the Web server, which holds all the files and data to build the application's base image and run the docker containers to our instances. The base image is a Docker image that will include all the dependencies required to run the application web-server, and its build with the help of Dockerfile and the commands define in it. From the base image then we are running three containers web-ui , web-api , and a worker with the help of the docker-compose file, as shown below. Alongside running our three containers from the base image, the docker-compose is also responsible to push NGINX container to our servers. which then proxies the requests to the web-ui , and web-api , as shown below:","title":"Web Server deployment"},{"location":"deployment/workflow/#docker-compose","text":"docker-compose is a tool for defining and running multi-container Docker applications In Repository there are two docker-compose files. doker-compose-test.yml As the name suggests this docker-compose file is used for Test Instance . docker-compose-prod.yml As the name suggests this docker-compose file is used for Production Instance . # -*- coding: utf-8 -*- # # Copyright (C) 2021 Graz University of Technology # Maintainer Mojib Wali # # Following services are included: # - Frontend server: Nginx (exposed port: 8080) # - UI application: UWSGI (not exposed) # - API application: UWSGI (not exposed) # - Worker: Celery (not exposed) version : '2.2' services : # Frontend frontend : image : registry.gitlab.tugraz.at/invenio/nginx:prod restart : \"always\" volumes : - static_data:/opt/invenio/var/instance/static links : - web-ui - web-api ports : - \"8080:8080\" # UI Application web-ui : command : [ \"uwsgi /opt/invenio/var/instance/uwsgi_ui.ini\" ] image : registry.gitlab.tugraz.at/invenio/repository:${TAG_PROD} env_file : ${ENV_FILE_PROD} ports : - \"5000\" volumes : - static_data:/opt/invenio/var/instance/static - uploaded_data:/opt/invenio/var/instance/data - archived_data:/opt/invenio/var/instance/archive # API Rest Application web-api : command : [ \"uwsgi /opt/invenio/var/instance/uwsgi_rest.ini\" ] image : registry.gitlab.tugraz.at/invenio/repository:${TAG_PROD} env_file : ${ENV_FILE_PROD} ports : - \"5000\" volumes : - uploaded_data:/opt/invenio/var/instance/data - archived_data:/opt/invenio/var/instance/archive # Worker worker : restart : \"always\" env_file : ${ENV_FILE_PROD} command : [ \"celery -A invenio_app.celery worker --loglevel=INFO\" ] image : registry.gitlab.tugraz.at/invenio/repository:${TAG_PROD} volumes : static_data : uploaded_data : driver : local driver_opts : type : none o : bind device : /storage archived_data : Both docker-compose files have the same commands, but diffrent conatiner names and environment variables.","title":"docker-compose"},{"location":"deployment/workflow/#dockerfile","text":"A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. The Dockerfile for Repository , as below. # Dockerfile that builds a fully functional image of your app. # # This image installs all Python dependencies for your application. It's based # on CentOS 8 with Python 3.8 (https://github.com/inveniosoftware/docker-invenio) # and includes Pip, Pipenv, Node.js, NPM and some few standard libraries # Repository usually needs. # Pulling Centos8 with python3.8 image. FROM inveniosoftware/centos8-python:3.8 # env arg ARG ENVIRONMENT # These packages are required for shibboleth authentication. # Installing xmlsec packages RUN yum localinstall -y http://mirror.centos.org/centos/8/PowerTools/x86_64/os/Packages/xmlsec1-devel-1.2.25-4.el8.x86_64.rpm \\ http://mirror.centos.org/centos/8/PowerTools/x86_64/os/Packages/xmlsec1-openssl-devel-1.2.25-4.el8.x86_64.rpm # Installing libtool package RUN yum localinstall -y http://mirror.centos.org/centos/8/AppStream/x86_64/os/Packages/libtool-ltdl-devel-2.4.6-25.el8.x86_64.rpm # Copy Pipfile and pipfile.lock to ./ directory COPY Pipfile Pipfile.lock ./ # Install all the dependecies defined in the Pipfile. RUN pipenv install --deploy --system --pre # Copy other necessary files COPY ./docker/uwsgi/ ${ INVENIO_INSTANCE_PATH } COPY ./prod/invenio.cfg ${ INVENIO_INSTANCE_PATH } COPY ./templates/ ${ INVENIO_INSTANCE_PATH } /templates/ COPY ./app_data/ ${ INVENIO_INSTANCE_PATH } /app_data/ COPY ./ . # This will create, install and build all the statics & assets. RUN cp -r ./static/. ${ INVENIO_INSTANCE_PATH } /static/ && \\ cp -r ./assets/. ${ INVENIO_INSTANCE_PATH } /assets/ && \\ invenio collect --verbose && \\ invenio webpack create && \\ invenio webpack install --unsafe && \\ invenio webpack build # Instruction used to configure how the container will run. ENTRYPOINT [ \"bash\" , \"-c\" ]","title":"Dockerfile"},{"location":"deployment/workflow/#pipeline","text":"","title":"Pipeline"},{"location":"deployment/workflow/#gitlab-ciyml","text":"is a YAML file that you create on your project's root. This file automatically runs whenever you push code in the repository. Pipelines consist of one or more stages that run in order and can each contain one or more jobs that run in parallel. These jobs (or scripts) get executed by the GitLab Runner agent. Repository pipeline consist of seven stages :","title":".gitlab-ci.yml"},{"location":"deployment/workflow/#dev","text":"In this stage the pipeline is building base image for Dev instance , and deploying it to the development server https://invenio-dev01.tugraz.at . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.dev.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Build and push base image to gitlab Container Registry .Using Tag name DEV . Run docker-compose for scripts in docker-compose.dev.yml file, and deploy to the development instance. Run wipe_recreate.sh scripts for clean Db, Es, Cache and demo rdm records. script: - echo \"build the image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$DEV --build-arg ENVIRONMENT=DEV . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$DEV - echo \"run docker-compose...\" - docker-compose -f docker-compose.dev.yml up -d - echo \"create demo records..\" - docker exec repository_web-api_1 chmod +x ./wipe_recreate.sh - docker exec repository_web-api_1 ./wipe_recreate.sh Only run for branch dev & merge_requests to the master branch. only: - dev - merge_requests Execute jobs with Gitlab-runner tag name dev : tags: - dev Full dev stage: dev-deploy: stage: dev before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.dev.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"build the image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$DEV --build-arg ENVIRONMENT=DEV . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$DEV - echo \"run docker-compose...\" - docker-compose -f docker-compose.dev.yml up -d - echo \"create demo records..\" - docker exec repository_web-api_1 chmod +x ./wipe_recreate.sh - docker exec repository_web-api_1 ./wipe_recreate.sh only: - dev - merge_requests tags: - dev","title":"dev"},{"location":"deployment/workflow/#build_test","text":"In this stage the pipeline is building base image for Test instance . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Build and push base image to gitlab Container Registry . Using Tag name TEST . script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$TEST --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$TEST Only run for branch master & test . only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell Full build_test stage: build-test: stage: build_test before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$TEST --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$TEST after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - shell","title":"build_test"},{"location":"deployment/workflow/#test_one","text":"In this stage pipeline is deploying the base image to the Web Server(invenio01-test) . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Run docker-compose, pull images and run containers defined in docker-compose.test.yml file. script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d Only run for branch master & test . only: - master Execute jobs with Gitlab-runner tag name test01 : tags: - test01 Logout from docker after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" Full test_one stage: test_one-deploy: stage: test_one before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test01","title":"test_one"},{"location":"deployment/workflow/#test_two","text":"In this stage pipeline is deploying the base image to the Web Server(invenio02-test) . Login to docker, clean docker cache, for containers, volumes and images. before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f Run docker-compose, pull images and run containers defined in docker-compose.test.yml file. script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d Only run for branch master & test . only: - master Execute jobs with Gitlab-runner tag name test02 : tags: - test02 Logout from docker after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" Full test_two stage: test_two-deploy: stage: test_two before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test02","title":"test_two"},{"location":"deployment/workflow/#full-gitlab-ciyml","text":"# environment variables # environment variables variables: DEV: dev TEST: test # Pipline stages stages: - dev - build_test - test_one - test_two - build_prod - prod_one - prod_two # Build & deploy stage for dev instance dev-deploy: stage: dev before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.dev.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"build the image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$DEV --build-arg ENVIRONMENT=DEV . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$DEV - echo \"run docker-compose...\" - docker-compose -f docker-compose.dev.yml up -d - echo \"create demo records..\" - docker exec repository_web-api_1 chmod +x ./wipe_recreate.sh - docker exec repository_web-api_1 ./wipe_recreate.sh only: - dev - merge_requests tags: - dev # Build stage for test instance build-test: stage: build_test before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$TEST --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$TEST after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - shell # Deploy stage for web server 01 test_one-deploy: stage: test_one before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test01 # Deploy stage for web server 02 test_two-deploy: stage: test_two before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.test.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.test.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - master tags: - test02 ################################################# # Build stage for prod build_prod: stage: build_prod before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"Build base image...\" - docker build --no-cache -t \"$CI_REGISTRY_IMAGE\":$CI_COMMIT_TAG --build-arg ENVIRONMENT=PROD . - echo \"Push image to the gitlab registry...\" - docker push \"$CI_REGISTRY_IMAGE\":$CI_COMMIT_TAG after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - tags tags: - shell # Deploy stage for web server 01 prod_one-deploy: stage: prod_one before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.prod.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.prod.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - tags tags: - prod01 # Deploy stage for web server 02 prod_two-deploy: stage: prod_two before_script: - echo \"login to docker...\" - echo \"$CI_REGISTRY_PASSWORD\" | docker login -u \"$CI_REGISTRY_USER\" --password-stdin \"$CI_REGISTRY\" - echo \"Clean docker cache, for containers, volumes and images...\" - docker-compose -f docker-compose.prod.yml down - docker system prune -f --volumes - docker system prune -a -f - docker image prune -f script: - echo \"run docker-compose...\" - docker-compose -f docker-compose.prod.yml up -d after_script: - echo \"Logout from docker...\" - \"docker logout ${CI_REGISTRY}\" only: - tags tags: - prod02","title":"Full .gitlab-ci.yml"},{"location":"deployment/workflow/#services-deployment","text":"Services such as Elasticsearch , PostgreSQL , Redis , EXIM4 , and RabbitMQ have a seperate repository in the Gitlab Group invenio . Except PostgreSQL other Services deployment are the same.","title":"Services deployment"},{"location":"deployment/workflow/#exim4","text":"","title":"EXIM4"},{"location":"deployment/workflow/#dockerfile_1","text":"A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. The Dockerfile for EXIM4 , as below. FROM debian:jessie # This dockerfile was inpired by greinacker/exim4 # install packages: exim4, mailutils RUN apt-get update \\ && apt-get install --no-install-recommends -y \\ exim4-daemon-light mailutils xtail vim \\ # Slim down image && apt-get clean \\ && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* /usr/share/man/?? /usr/share/man/??_* # add the exim4 start script ADD start.sh /exim_start RUN chmod +x /exim_start ENV EXIM_LOCALINTERFACE = 0 .0.0.0 ENTRYPOINT [ \"/exim_start\" ]","title":"Dockerfile"},{"location":"deployment/workflow/#deploy-prodsh","text":"Is a helper file for deployment, and used by .gitlab-ci.yml . It contains instruction for docker commands. CONTAINER_NAME = smarthost IMAGE_NAME = registry.gitlab.tugraz.at/invenio/exim4:latest echo \"################################################\" echo \"Stopping and removing container with given name...... $CONTAINER_NAME \" docker stop $CONTAINER_NAME || true && docker rm $CONTAINER_NAME || true echo \"################################################\" echo \"Removing image if given name exists... $IMAGE_NAME \" if test ! -z \" $( docker images -q $IMAGE_NAME ) \" ; then echo \"Image exist...\" docker rmi -f $IMAGE_NAME fi echo \"################################################\" echo \"Running new container..............\" docker run --name = \" $CONTAINER_NAME \" -p 25 :25 -d \\ -e HOSTNAME = \"repository.tugraz.at\" \\ -e EXIM_SMARTHOST = \"**********\" \\ -e EXIM_PASSWORD = \"**********\" \\ -e EXIM_LOCALINTERFACE = \"0.0.0.0\" \\ -e EXIM_DOMAIN = \"repository.tugraz.at\" \\ -e EXIM_ALLOWED_SENDERS = \"**********/28, **********/28\" \\ --restart = always \\ $IMAGE_NAME echo \"################################################\" echo \"job ended...\"","title":"deploy-prod.sh"},{"location":"deployment/workflow/#gitlab-ciyml_1","text":"EXIM4 pipeline consist of three stages","title":".gitlab-ci.yml"},{"location":"deployment/workflow/#build","text":"Pipeline builds the docker image and pushes it to the Registry. Login to docker: before_script: - echo \"################################\" - echo \"login to docker...\" - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY Build and push docker image: script: - echo \"################################\" - echo \"Building the image...\" - docker build -t \"$CI_REGISTRY_IMAGE\" . - echo \"push image to registry...\" - docker push \"$CI_REGISTRY_IMAGE\" Only run for branch master : only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell","title":"build"},{"location":"deployment/workflow/#test","text":"In this stage the pipeline pulls the newly created image and creates a container to the Test instance. before_script run followings: Install ssh-agent if not already installed, it is required by Docker. Run ssh-agent (inside the build environment) Add the SSH key stored in SERVER_3_PRIVATE_KEY variable to the agent store Create the SSH directory and give it the right permissions scan the keys of your private server from variable SSH_SERVER_HOSTKEYS before_script: - echo \"SSH-USER\" - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' - eval $(ssh-agent -s) - echo \"$SERVER_3_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script : using ssh commands logs in to docker, and runs scripts in deploy-test.sh to our server. script: - ssh $SERVER_3_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $SERVER_3_DOMAIN \"eval '$(cat ./deploy-test.sh)'\" Only run for branch master : only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell","title":"test"},{"location":"deployment/workflow/#prod","text":"In this stage the pipeline pulls the newly created image and creates a container to the Production instance. before_script run followings: Install ssh-agent if not already installed, it is required by Docker. Run ssh-agent (inside the build environment) Add the SSH key stored in PROD_03_PRIVATE_KEY variable to the agent store Create the SSH directory and give it the right permissions scan the keys of your private server from variable SSH_SERVER_HOSTKEYS before_script: - echo \"SSH-USER\" - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' - eval $(ssh-agent -s) - echo \"$PROD_03_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - - mkdir -p ~/.ssh - chmod 700 ~/.ssh - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script : using ssh commands logs in to docker, and runs scripts in deploy-prod.sh to our server. script: - ssh $PROD_03_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $PROD_03_DOMAIN \"eval '$(cat ./deploy-prod.sh)'\" Only run for branch master : only: - master Execute jobs with Gitlab-runner tag name shell : tags: - shell","title":"prod"},{"location":"deployment/workflow/#full-gitlab-ciyml_1","text":"stages: - build - test - prod build: stage: build before_script: - echo \"################################\" - echo \"login to docker...\" - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY script: - echo \"################################\" - echo \"Building the image...\" - docker build -t \"$CI_REGISTRY_IMAGE\" . - echo \"push image to registry...\" - docker push \"$CI_REGISTRY_IMAGE\" only: - master tags: - shell test: stage: test before_script: - echo \"################################\" - echo \"SSH-USER\" ## ## Install ssh-agent if not already installed, it is required by Docker. ## (change apt-get to yum if you use an RPM-based image) ## - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' ## ## Run ssh-agent (inside the build environment) ## - eval $(ssh-agent -s) ## ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store ## We're using tr to fix line endings which makes ed25519 keys work ## without extra base64 encoding. ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556 ## - echo \"$SERVER_3_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - ## ## Create the SSH directory and give it the right permissions ## - mkdir -p ~/.ssh - chmod 700 ~/.ssh ## ## Use ssh-keyscan to scan the keys of your private server. Replace gitlab.com ## with your own domain name. You can copy and repeat that command if you have ## more than one server to connect to. ## #- ssh-keyscan invenio03-test.tugraz.at >> ~/.ssh/known_hosts #- chmod 644 ~/.ssh/known_hosts ## ## Alternatively, assuming you created the SSH_SERVER_HOSTKEYS variable ## previously, uncomment the following two lines instead. ## - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script: - echo \"################################\" - ssh $SERVER_3_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $SERVER_3_DOMAIN \"eval '$(cat ./deploy-test.sh)'\" only: - master tags: - shell prod: stage: prod before_script: - echo \"################################\" - echo \"SSH-USER\" ## ## Install ssh-agent if not already installed, it is required by Docker. ## (change apt-get to yum if you use an RPM-based image) ## - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client git -y )' ## ## Run ssh-agent (inside the build environment) ## - eval $(ssh-agent -s) ## ## Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store ## We're using tr to fix line endings which makes ed25519 keys work ## without extra base64 encoding. ## https://gitlab.com/gitlab-examples/ssh-private-key/issues/1#note_48526556 ## - echo \"$PROD_03_PRIVATE_KEY\" | tr -d '\\r' | ssh-add - ## ## Create the SSH directory and give it the right permissions ## - mkdir -p ~/.ssh - chmod 700 ~/.ssh ## ## Use ssh-keyscan to scan the keys of your private server. Replace gitlab.com ## with your own domain name. You can copy and repeat that command if you have ## more than one server to connect to. ## #- ssh-keyscan invenio03-test.tugraz.at >> ~/.ssh/known_hosts #- chmod 644 ~/.ssh/known_hosts ## ## Alternatively, assuming you created the SSH_SERVER_HOSTKEYS variable ## previously, uncomment the following two lines instead. ## - echo \"$SSH_SERVER_HOSTKEYS\" > ~/.ssh/known_hosts - chmod 644 ~/.ssh/known_hosts script: - echo \"################################\" - ssh $PROD_03_DOMAIN \"echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER $CI_REGISTRY --password-stdin\" - ssh $PROD_03_DOMAIN \"eval '$(cat ./deploy-prod.sh)'\" only: - master tags: - shell","title":"Full .gitlab-ci.yml"}]}